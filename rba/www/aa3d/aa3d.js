// Generated by CoffeeScript 1.9.3
var addDoms_mergedgeomery, addDoms_shader, addHits_manymeshes, addHits_shader, addVRButton, antares_mode, callbacks, camera, clamp, clight, container, containerHeight, containerWidth, controls, dbg_cam, defpars, det, distFromCamera, dus, effect, eventtime, evil, evt, geometry, getConeMesh, getCylinderMesh, getHitColor, getSceneObj, getUrlPar, gui, handlefile, ii, init, initdiv, isLepton, isMuon, isNeutrino, isvec, light, loadFile, make_hitcol, many_screenshots, material, mesh, mouseVector, newwindow, pars, populateHitInstanceBuffers, raycaster, render, renderer, scene, selected, selectedHit, showSelectionInfo, stats, str_endsWith, timeParameter, tovec, trackColor, trackLength, train, unzip, url, vadd, vlen, vmul, vr_demo1, vsub;

pars = {};

defpars = {};

clight = 0.299792458;

evt = {
  "hits": [],
  "trks": []
};

det = {
  "doms": [
    {
      "id": 1,
      "dir": {
        "y": 0,
        "x": 0,
        "z": 0
      },
      "pos": {
        "y": 0,
        "x": 0,
        "z": 0
      }
    }
  ]
};

scene = camera = renderer = raycaster = mouseVector = controls = null;

geometry = material = mesh = null;

container = stats = gui = null;

containerWidth = containerHeight = null;

eventtime = 0.0;

light = null;

gui = null;

effect = null;

train = null;

selectedHit = null;

ii = null;

dus = 42;

callbacks = {};

selected = null;

dbg_cam = false;

evil = function(code) {
  return eval(code);
};

isvec = function(obj) {
  return typeof obj === 'object' && 'x' in obj && 'y' in obj && 'z' in obj;
};

vadd = function(v1, v2) {
  return {
    x: v1.x + v2.x,
    y: v1.y + v2.y,
    z: v1.z + v2.z
  };
};

vsub = function(v1, v2) {
  return {
    x: v1.x - v2.x,
    y: v1.y - v2.y,
    z: v1.z - v2.z
  };
};

vmul = function(v1, a) {
  if (typeof v1 === 'number') {
    return vmul(a, v1);
  }
  return {
    x: v1.x * a,
    y: v1.y * a,
    z: v1.z * a
  };
};

vlen = function(v1, v2) {
  if (v2 == null) {
    v2 = {
      x: 0,
      y: 0,
      z: 0
    };
  }
  return Math.sqrt((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y) + (v1.z - v2.z) * (v1.z - v2.z));
};

tovec = function(obj) {
  return new THREE.Vector3(obj.y, obj.z, obj.x);
};

clamp = function(x, min, max) {
  if (min == null) {
    min = 0;
  }
  if (max == null) {
    max = 1;
  }
  if (x <= min) {
    return min;
  }
  if (x >= max) {
    return max;
  }
  return x;
};

getUrlPar = function(name, url) {
  var regex, results;
  if (url == null) {
    url = window.location.href;
  }
  name = name.replace(/[\[\]]/g, "\\$&");
  regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)");
  results = regex.exec(url);
  if (!results) {
    return null;
  }
  if (!results[2]) {
    return '';
  }
  return decodeURIComponent(results[2].replace(/\+/g, " "));
};

getCylinderMesh = function(startpoint, endpoint, width, material, width2) {
  var geom, l;
  l = vlen(endpoint, startpoint);
  if (width2 == null) {
    width2 = width;
  }
  geom = new THREE.CylinderGeometry(width, width2, l);
  geom.translate(0, l / 2, 0);
  geom.rotateX(Math.PI / 2);
  mesh = new THREE.Mesh(geom, material.clone());
  mesh.position.set(startpoint.y, startpoint.z, startpoint.x);
  mesh.lookAt(tovec(endpoint));
  return mesh;
};

getConeMesh = function(startpoint, endpoint, width, material) {
  return getCylinderMesh(startpoint, endpoint, width, material, 0);
};

callbacks.setBackgroundColor = function() {
  return scene.background = new THREE.Color(pars.bgColor);
};

callbacks.screenshot = function() {
  var dt;
  dt = renderer.domElement.toDataURL('image/png');
  return window.open(dt, 'screenshot');
};

callbacks.screenshot360 = function() {
  var X;
  console.log("screenshot360");
  X = new CubemapToEquirectangular(renderer, true);
  return X.update(camera, scene);
};

callbacks.write_screenshot = function(fn) {
  var http, params, url;
  url = "uploadimg.php";
  params = "fn=" + fn + ".png&payload=" + renderer.domElement.toDataURL('image/png');
  console.log(params);
  http = new XMLHttpRequest();
  http.open("POST", url, false);
  http.send(params);
  if (http.readyState === 4 && http.status === 200) {
    return console.log(http.responseText);
  } else {
    return console.log('error sending screenshot');
  }
};

callbacks.addCamera = function() {
  if (camera == null) {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 10000);
  }
  camera.position.x = 0;
  camera.position.y = pars.camHeight;
  return camera.position.z = pars.camDistance;
};

callbacks.addOrbitControls = function() {
  var cg;
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  cg = det.cg || {
    x: 0,
    y: 0,
    z: 0
  };
  controls.center = new THREE.Vector3(cg.z, cg.y, cg.x) || new THREE.Vector3(camera.position.x, camera.position.y, 0.0);
  controls.update();
  controls.addEventListener('change', render);
  return controls;
};

getSceneObj = function(name) {
  var obj;
  while (obj = scene.getObjectByName(name)) {
    scene.remove(obj);
  }
  obj = new THREE.Object3D();
  obj.name = name;
  scene.add(obj);
  return obj;
};

isNeutrino = function(track) {
  var ref;
  return (ref = Math.abs(track.type)) === 12 || ref === 14 || ref === 16;
};

isLepton = function(track) {
  var ref;
  return (ref = Math.abs(track.type)) === 11 || ref === 13 || ref === 15;
};

isMuon = function(track) {
  return Math.abs(track.type) === 13;
};

trackColor = function(track) {
  if (track.type === 0) {
    return new THREE.Color(pars.trackColor);
  }
  if (isNeutrino(track)) {
    return new THREE.Color(pars.neuColor);
  }
  if (isMuon(track)) {
    return new THREE.Color(pars.muColor);
  }
  return new THREE.Color(pars.mcTrackColor);
};

trackLength = function(track) {
  var l;
  if (isMuon(track)) {
    if ((track.len != null) !== 0) {
      return Math.abs(track.len);
    }
    if (track.E != null) {
      l = track.E * 5;
      if (l < 20) {
        l = 20;
      }
      if (l > 4000) {
        l = 4000;
      }
    }
    return l;
  }
  if (track.len > 0) {
    return track.len;
  }
  return pars.trackLen;
};

addDoms_mergedgeomery = function() {
  var d, dom, doms, geo, group, id, mat, mergedGeo, ref;
  if (!pars.showDoms) {
    return;
  }
  doms = getSceneObj("doms");
  geo = new THREE.SphereGeometry(pars.domSize, 2 * pars.domDetail, pars.domDetail);
  mat = new THREE.MeshLambertMaterial({
    color: new THREE.Color(pars.domColor)
  });
  mesh = new THREE.Mesh(geo);
  mergedGeo = new THREE.Geometry();
  ref = det.doms;
  for (id in ref) {
    dom = ref[id];
    if (dom.dir != null) {
      d = vmul(pars.domFactor, dom.dir);
    } else {
      d = {
        x: 0,
        y: 0,
        z: 1
      };
    }
    mesh.position.set(dom.pos.y + d.y, dom.pos.z + d.z, dom.pos.x + d.x);
    mesh.updateMatrix();
    mergedGeo.merge(mesh.geometry, mesh.matrix);
  }
  group = new THREE.Mesh(mergedGeo, mat);
  return doms.add(group);
};

addDoms_shader = function() {
  var d, dom, doms, geo, group, i, id, ndoms, offsets, orientations, ref, ref1, sphere, uniforms_;
  if (!pars.showDoms) {
    return;
  }
  doms = getSceneObj("doms");
  geo = new THREE.InstancedBufferGeometry();
  sphere = new THREE.SphereGeometry(pars.domSize, 2 * pars.domDetail, pars.domDetail);
  sphere.rotateX(Math.PI);
  geo.fromGeometry(sphere);
  ndoms = 0;
  ref = det.doms;
  for (id in ref) {
    dom = ref[id];
    ndoms++;
  }
  offsets = new THREE.InstancedBufferAttribute(new Float32Array(ndoms * 3), 3, 1);
  orientations = new THREE.InstancedBufferAttribute(new Float32Array(ndoms * 3), 3, 1);
  i = 0;
  ref1 = det.doms;
  for (id in ref1) {
    dom = ref1[id];
    if ((dom.dir == null) || dom.dir.z > 0) {
      dom.dir = {
        x: 0,
        y: 0,
        z: 1
      };
      d = {
        x: 0,
        y: 0,
        z: 0
      };
    } else {
      d = vmul(pars.domFactor, dom.dir);
    }
    offsets.setXYZ(i, dom.pos.y + d.y, dom.pos.z + d.z, dom.pos.x + d.x);
    orientations.setXYZ(i, dom.dir.y, dom.dir.z, dom.dir.x);
    i += 1;
  }
  geo.addAttribute('offset', offsets);
  geo.addAttribute('orientation', orientations);
  uniforms_ = THREE.UniformsUtils.merge([THREE.UniformsLib["ambient"], THREE.UniformsLib["lights"]]);
  material = new THREE.RawShaderMaterial({
    uniforms: uniforms_,
    vertexShader: vertexshader_glsl,
    fragmentShader: window[pars.domFragmentShader],
    side: THREE.DoubleSide,
    lights: true,
    transparent: false
  });
  group = new THREE.Mesh(geo, material);
  group.frustumCulled = false;
  return doms.add(group);
};

callbacks.addDoms = addDoms_shader;

callbacks.addFloor = function() {
  var dom, floor, geo, id, mat, texture;
  floor = getSceneObj("floor");
  det.floor_z = det.floor_z || Math.min.apply(Math, (function() {
    var ref, results1;
    ref = det.doms;
    results1 = [];
    for (id in ref) {
      dom = ref[id];
      results1.push(dom.pos.z);
    }
    return results1;
  })()) - 100;
  console.log("addFloor", det.floor_z);
  texture = new THREE.TextureLoader().load('textures/image.png');
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(100, 100);
  geo = new THREE.PlaneGeometry(20000, 20000, 1, 1);
  mat = new THREE.MeshBasicMaterial({
    color: pars.floorColor,
    side: THREE.DoubleSide,
    opacity: pars.floorOpacity,
    transparent: false,
    map: texture
  });
  mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = 0.5 * Math.PI;
  mesh.position.y = det.floor_z;
  return floor.add(mesh);
};

callbacks.addStrings = function() {
  var endpos, j, len, mat, ref, results1, startpos, stringpos, strings;
  if (!pars.showStrings) {
    return;
  }
  if (!det.strings) {
    return;
  }
  strings = getSceneObj("strings");
  mat = new THREE.MeshLambertMaterial({
    color: new THREE.Color(pars.stringColor)
  });
  endpos = null;
  ref = det.strings;
  results1 = [];
  for (j = 0, len = ref.length; j < len; j++) {
    stringpos = ref[j];
    startpos = tovec(stringpos);
    if (endpos) {
      mesh = getCylinderMesh(startpos, endpos, pars.stringWidth, mat);
      strings.add(mesh);
    }
    results1.push(endpos = startpos);
  }
  return results1;
};

timeParameter = function(hit, track) {
  switch (pars.colScheme) {
    case 'time':
      return hit.t;
    case 'track':
      return hit.t - time_track(track, hit.pos);
    case 'shower':
      return hit.t - time_shower(track, hit.pos);
  }
};

getHitColor = function(time, timerange, track) {
  var aa, col, maxt, mint;
  mint = timerange[0], maxt = timerange[1];
  aa = (time - mint) / (maxt - mint);
  col = new THREE.Color();
  if (pars.palette === 'hue') {
    col.setHSL(aa, 1.0, 0.5);
  }
  if (pars.palette === 'doppler') {
    col.setRGB(1 - clamp(aa * aa), 0, clamp(aa * 2 - 1));
  }
  return col;
};

addHits_manymeshes = function() {
  var a, amp, col, d, geo, have_direction, hit, hitarray, hits, j, len, mat, results1;
  hits = getSceneObj("hits");
  hitarray = evt[pars.hitSet];
  if (!hitarray) {
    return;
  }
  if (pars.hitStyle === 'sphere') {
    geo = new THREE.SphereGeometry(2, 2 * pars.hitDetail, pars.hitDetail);
  }
  if (pars.hitStyle === 'disk') {
    geo = new THREE.CylinderGeometry(2, 2, 0.1, pars.hitDetail, 1);
    geo.translate(0, 0.05, 0);
    geo.rotateX(Math.PI / 2);
    have_direction = true;
  }
  evt.timerange = evt.timerange || [
    Math.min.apply(Math, (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = hitarray.length; j < len; j++) {
        hit = hitarray[j];
        results1.push(hit.t);
      }
      return results1;
    })()), Math.max.apply(Math, (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = hitarray.length; j < len; j++) {
        hit = hitarray[j];
        results1.push(hit.t);
      }
      return results1;
    })())
  ];
  eval('ampfun = function(hit) { return ' + pars.ampFunc + ';};');
  results1 = [];
  for (j = 0, len = hitarray.length; j < len; j++) {
    hit = hitarray[j];
    if (pars.animate && hit.t > eventtime) {
      continue;
    }
    col = getHitColor(hit.t, evt.timerange);
    mat = new THREE.MeshLambertMaterial({
      color: col
    });
    mesh = new THREE.Mesh(geo, mat);
    mesh.t = hit.t;
    d = hit.dir || {
      x: 0,
      y: 0,
      z: 0
    };
    a = pars.domFactor;
    mesh.position.set(hit.pos.y + a * d.y, hit.pos.z + a * d.z, hit.pos.x + a * d.x);
    a *= 2;
    if (have_direction) {
      mesh.lookAt(new THREE.Vector3(hit.pos.y + a * d.y, hit.pos.z + a * d.z, hit.pos.x + a * d.x));
    }
    amp = ampfun(hit) * pars.hitLength;
    if (pars.hitStyle === 'sphere') {
      mesh.scale.set(amp, amp, amp);
    }
    if (pars.hitStyle === 'disk') {
      mesh.scale.set(1, 1, amp);
    }
    results1.push(hits.add(mesh));
  }
  return results1;
};

callbacks.animateHits_manymeshes = function() {
  var hits, j, len, results1;
  hits = scene.getObjectByName("hits").children;
  results1 = [];
  for (j = 0, len = hits.length; j < len; j++) {
    mesh = hits[j];
    results1.push(mesh.visible = mesh.t > eventtime && mesh.t < (eventtime + 200));
  }
  return results1;
};

distFromCamera = function(pos) {
  var r, x, y, z;
  x = pos.y - camera.position.x;
  y = pos.z - camera.position.y;
  z = pos.x - camera.position.z;
  r = x * x + y * y + z * z;
  return r;
};

populateHitInstanceBuffers = function() {
  return window.alert("populateHitInstanceBuffers cannot be called before addHits_shader");
};

make_hitcol = function(hitlist) {
  var X, hit, hitcol, j, k, len, name1, v;
  X = {};
  for (j = 0, len = hitlist.length; j < len; j++) {
    hit = hitlist[j];
    (X[name1 = hit.dom_id] != null ? X[name1] : X[name1] = []).push(hit);
  }
  hitcol = (function() {
    var results1;
    results1 = [];
    for (k in X) {
      v = X[k];
      results1.push(v);
    }
    return results1;
  })();
  hitcol.doms_are_sorted = function(verbose) {
    var h, hitsondom, len1, m, olddepth, r;
    olddepth = 1e10;
    r = true;
    for (m = 0, len1 = this.length; m < len1; m++) {
      hitsondom = this[m];
      h = hitsondom[0];
      h.depth = distFromCamera(h.pos);
      if (verbose) {
        console.log(h.depth);
      }
      if (h.depth > olddepth) {
        r = false;
      }
      olddepth = h.depth;
    }
    return r;
  };
  hitcol.dbg = function() {
    var i, len1, lst, m, results1;
    results1 = [];
    for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
      lst = this[i];
      console.log(i, lst[0].depth);
      if (i > 10) {
        break;
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };
  hitcol.sort_doms = function() {
    return this.sort(function(lst1, lst2) {
      return lst1[0].depth < lst2[0].depth;
    });
  };
  hitcol.sort_within_doms = function() {
    var h, len1, len2, lst, m, n, results1;
    results1 = [];
    for (m = 0, len1 = this.length; m < len1; m++) {
      lst = this[m];
      for (n = 0, len2 = lst.length; n < len2; n++) {
        h = lst[n];
        h.depth = distFromCamera(h.pos);
      }
      results1.push(lst.sort(function(h1, h2) {
        return h1.depth < h2.depth;
      }));
    }
    return results1;
  };
  hitcol.sort_all = function() {
    if (!this.doms_are_sorted()) {
      this.sort_doms();
      this.sort_within_doms();
      return populateHitInstanceBuffers();
    }
  };
  return hitcol;
};

callbacks.depthSort = function() {
  var t0, t1;
  t0 = (new Date()).getTime();
  evt.sorted_hits.sort_all();
  t1 = (new Date()).getTime();
  return console.log("depthSort took", t1 - t0);
};

callbacks.onNewEvent = function() {
  var j, len, ref, trk, vv;
  evt.tag = "evt";
  evt.sorted_hits = make_hitcol(evt.hits);
  evt.sorted_mc_hits = make_hitcol(evt.mc_hits);
  ref = evt.mc_trks;
  for (j = 0, len = ref.length; j < len; j++) {
    trk = ref[j];
    if (isNeutrino(trk)) {
      vv = vmul(10000.0, trk.dir);
      trk.pos = vsub(trk.pos, vv);
      trk.len = 10000;
      trk.t = trk.t - trk.len / clight;
    }
  }
  if (scene != null) {
    callbacks.addHits();
    return callbacks.addTracks();
  }
};

callbacks.onNewDetector = function() {
  var dom, id, ref, results1;
  console.log('onNewDetector');
  if (det.name === "antares") {
    antares_mode();
  }
  det.tag = "det";
  det.cg = {
    x: 0,
    y: 0,
    z: 0
  };
  det.ndoms = 0;
  ref = det.doms;
  results1 = [];
  for (id in ref) {
    dom = ref[id];
    det.ndoms += 1;
    results1.push(det.cg = vadd(det.cg, dom.pos));
  }
  return results1;
};

addHits_shader = function() {
  var a, amplitudes, colors, disk, geo, hit, hitarray, hits, nhits, offsets, orientations, times, tots;
  hits = getSceneObj("hits");
  hitarray = evt[pars.hitSet];
  if (!hitarray) {
    return;
  }
  console.log('addHits', hitarray.length);
  evt.timerange = [
    Math.min.apply(Math, (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = hitarray.length; j < len; j++) {
        hit = hitarray[j];
        results1.push(hit.t);
      }
      return results1;
    })()), Math.max.apply(Math, (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = hitarray.length; j < len; j++) {
        hit = hitarray[j];
        results1.push(hit.t);
      }
      return results1;
    })())
  ];
  geo = new THREE.InstancedBufferGeometry();
  disk = new THREE.CylinderGeometry(pars.hitWidth, 3 * pars.hitWidth, 0.1, pars.hitDetail, 1);
  disk.translate(0, -0.05, 0);
  disk.rotateZ(Math.PI / 2);
  geo.fromGeometry(disk);
  nhits = hitarray.length;
  offsets = new THREE.InstancedBufferAttribute(new Float32Array(nhits * 3), 3, 1).setDynamic(true);
  orientations = new THREE.InstancedBufferAttribute(new Float32Array(nhits * 3), 3, 1).setDynamic(true);
  colors = new THREE.InstancedBufferAttribute(new Float32Array(nhits * 3), 3, 1).setDynamic(true);
  amplitudes = new THREE.InstancedBufferAttribute(new Float32Array(nhits), 1, 1).setDynamic(true);
  times = new THREE.InstancedBufferAttribute(new Float32Array(nhits), 1, 1).setDynamic(true);
  tots = new THREE.InstancedBufferAttribute(new Float32Array(nhits), 1, 1).setDynamic(true);
  geo.addAttribute('offset', offsets);
  geo.addAttribute('orientation', orientations);
  geo.addAttribute('color', colors);
  geo.addAttribute('amplitude', amplitudes);
  geo.addAttribute('time', times);
  geo.addAttribute('tot', tots);
  a = pars.domFactor;
  populateHitInstanceBuffers = function() {
    var col, d, domhits, i, j, len, len1, m, ref, t1, t2;
    eval('ampfun = function(hit) { return ' + pars.ampFunc + ';};');
    t1 = (new Date()).getTime();
    i = 0;
    ref = evt.sorted_hits;
    for (j = 0, len = ref.length; j < len; j++) {
      domhits = ref[j];
      for (m = 0, len1 = domhits.length; m < len1; m++) {
        hit = domhits[m];
        col = getHitColor(hit.t, evt.timerange);
        d = hit.dir || {
          x: 0,
          y: 0,
          z: 1
        };
        offsets.setXYZ(i, hit.pos.y + a * d.y, hit.pos.z + a * d.z, hit.pos.x + a * d.x);
        orientations.setXYZ(i, hit.dir.y, hit.dir.z, hit.dir.x);
        colors.setXYZ(i, col.r, col.g, col.b);
        amplitudes.setX(i, ampfun(hit) * pars.hitLength);
        times.setX(i, hit.t);
        tots.setX(i, hit.tot * pars['aniTotFactor']);
        i += 1;
      }
    }
    t2 = (new Date()).getTime();
    offsets.needsUpdate = true;
    orientations.needsUpdate = true;
    colors.needsUpdate = true;
    amplitudes.needsUpdate = true;
    times.needsUpdate = true;
    return tots.needsUpdate = true;
  };
  populateHitInstanceBuffers();
  material = new THREE.RawShaderMaterial({
    uniforms: {
      "eventtime": {
        type: "1f",
        value: 0
      }
    },
    vertexShader: hit_vertexshader_glsl,
    fragmentShader: hit_fragmentshader_glsl,
    side: THREE.BackSide,
    transparent: true
  });
  mesh = new THREE.Mesh(geo, material);
  mesh.frustumCulled = false;
  return hits.add(mesh);
};

callbacks['addHits'] = function() {
  if (pars.hitStyle === 'cone') {
    return addHits_shader();
  } else {
    return addHits_manymeshes();
  }
};

callbacks.addTracks = function() {
  var endpos, j, len, mat, results1, startpos, startt, t, trk, trkcol, trklen, trks;
  trks = getSceneObj('trks');
  if (typeof t === 'undefined') {
    t = 1e10;
  }
  trkcol = evt[pars.tracks] || [];
  results1 = [];
  for (j = 0, len = trkcol.length; j < len; j++) {
    trk = trkcol[j];
    trklen = trackLength(trk);
    startpos = trk.pos;
    endpos = vadd(trk.pos, vmul(trk.dir, trklen));
    startt = trk.t;
    if (isNeutrino(trk)) {
      startpos = vadd(trk.pos, vmul(trk.dir, -trklen));
      endpos = trk.pos;
      startt -= trklen / clight;
    }
    mat = new THREE.MeshPhongMaterial({
      emissive: new THREE.Color(trackColor(trk)),
      transparent: false,
      opacity: 0.5
    });
    mesh = getCylinderMesh(startpos, endpos, pars.trackWidth, mat);
    mesh.t0 = startt;
    mesh.t1 = startt + trklen / clight;
    console.log("track", startpos, endpos, trklen);
    results1.push(trks.add(mesh));
  }
  return results1;
};

callbacks.animateTracks = function(t) {
  var f, j, len, ref, results1, trks;
  trks = scene.getObjectByName('trks');
  ref = trks.children;
  results1 = [];
  for (j = 0, len = ref.length; j < len; j++) {
    mesh = ref[j];
    f = clamp((t - mesh.t0) / (mesh.t1 - mesh.t0));
    results1.push(mesh.scale.set(1, 1, f));
  }
  return results1;
};

callbacks.addEvt = function() {
  callbacks.addHits();
  return callbacks.addTracks();
};

callbacks.addDet = function() {
  callbacks.addFloor();
  callbacks.addStrings();
  return callbacks.addDoms();
};

handlefile = function(e) {
  return console.log("filetje:", e.target.files);
};

callbacks.loadLocalFile = function() {
  var element, fileInput;
  element = document.createElement('div');
  element.innerHTML = '<input type="file">';
  fileInput = element.firstChild;
  fileInput.addEventListener('change', handlefile);
  return fileInput.click();
};

gui = window.buildmenu(pars, callbacks);

callbacks.vr_demo = function(tnow) {
  var name1;
  return typeof window[name1 = pars.demo] === "function" ? window[name1](tnow) : void 0;
};

vr_demo1 = function(tnow) {
  return train.position.y = 500 + 400 * Math.sin(tnow / 10000.0);
};

addVRButton = function() {
  return WEBVR.getVRDisplay(function(display) {
    if (display == null) {
      console.log("no vr display found");
      return;
    }
    renderer.vr.setDevice(display);
    return gui.add({
      "VR_mode": function() {
        console.log("toggling vr mode!");
        controls = new THREE.VRControls(camera);
        effect = new THREE.VREffect(renderer);
        if (display.isPresenting) {
          display.exitPresent();
        }
        return {
          "else": display.requestPresent([
            {
              source: renderer.domElement
            }
          ])
        };
      }
    }, "VR_mode");
  });
};

init = function() {
  var al, attrname, t1, t2, websock;
  t1 = (new Date()).getTime();
  scene = new THREE.Scene();
  console.log("bg col = ", pars.bgColor);
  renderer = new THREE.WebGLRenderer({
    preserveDrawingBuffer: true,
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);
  stats = new Stats();
  container.appendChild(stats.dom);
  window.addEventListener('resize', onWindowResize, false);
  light = new THREE.PointLight(0xffffff);
  light.position.set(500, 1000, 0);
  scene.add(light);
  al = new THREE.AmbientLight(0x444444);
  scene.add(al);
  for (attrname in defpars) {
    pars[attrname] = defpars[attrname];
  }
  console.log('call addcontrols', renderer);
  callbacks.setBackgroundColor();
  callbacks.addCamera();
  callbacks.addStrings();
  callbacks.addDoms();
  callbacks.addTracks();
  callbacks.addHits();
  callbacks.addFloor();
  callbacks.addOrbitControls();
  train = new THREE.Object3D();
  train.position.set(0, 0, 0);
  scene.add(train);
  train.add(camera);
  addVRButton();
  raycaster = new THREE.Raycaster();
  mouseVector = new THREE.Vector2();
  showSelectionInfo(evt);
  t2 = (new Date()).getTime();
  console.log("init took (ms) : ", t2 - t1);
  websock = new WebSocket("ws://www.cherenkov.nl:8181", "protocolOne");
  websock.onmessage = function(event) {
    var s;
    console.oldlog("get wesocket message:", event.data);
    s = eval(event.data);
    return console.log(JSON.stringify(s));
  };
  return websock.onopen = function() {
    console.oldlog = console.log;
    return console.log = function() {
      var a;
      a = Array.prototype.slice.call(arguments);
      console.oldlog(arguments);
      return websock.send(a.toString());
    };
  };
};

showSelectionInfo = function() {
  var M, html, infodiv, key, val;
  if (selected == null) {
    selected = evt;
  }
  infodiv = document.getElementById("info");
  if (!infodiv) {
    infodiv = document.createElement('div');
    infodiv.id = 'info';
    infodiv.big = false;
    infodiv.addEventListener("click", function() {
      console.log('click');
      infodiv.big = !infodiv.big;
      return showSelectionInfo();
    });
    document.body.appendChild(infodiv);
  }
  M = {
    'trk': 'Track',
    'hit': 'Hit',
    'evt': 'Event'
  };
  html = " <h3> " + M[selected.tag] + " " + selected.id + " </h3> <table style=\"width:100%\"><tr> ";
  if (infodiv.big) {
    for (key in selected) {
      val = selected[key];
      if (Array.isArray(val)) {
        val = val.length.toString() + "entries";
      }
      if (isvec(val)) {
        val = val.x.toFixed(3)(+', ' + val.y.toFixed(3) + ', ' + val.z.toFixed(3));
      }
      html += '<tr><td> ' + key + ' </td><td> ' + val + '</td></tr>';
    }
  }
  html += '</table>';
  return infodiv.innerHTML = html;
};





function onMouseMove( e ) 
{
	console.log ("mousemove")

    mouseVector.x = 2 * (e.clientX / window.innerWidth ) - 1;
    mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
    
    raycaster.setFromCamera( mouseVector, camera );
    
    var searchObjects = ["hits","trks"]; 
    
    flag = false;

        if ( selectedHit) 
        {
                selectedHit.material.emissive.setHex( selectedHit.oldHex); 
        }


    for ( var ii = 0; ii<searchObjects.length; ii++ )
    {
        var collection = scene.getObjectByName( searchObjects[ii] );
        
        console.log( collection );
        
        var intersects = raycaster.intersectObjects( collection.children );
        
        console.log("intersects", intersects );

               
        if ( intersects.length > 0 ) 
        {
        var sel = intersects[ 0 ].object;
        
        if ( sel.hasOwnProperty("aaobj") ) 
        {
            selectedHit = sel;
            
            sel.oldHex = sel.material.emissive.getHex();
            sel.material.emissive.setHex( 0xff0000 );
    
            sel.aaobj.tag = searchObjects[ii].substring(0,3);
        
            showSelectionInfo( sel.aaobj );
            flag = true;
        }
        }
    }
    
    evt.tag = "evt";
    if (!flag)  showSelectionInfo( evt );
}


function onWindowResize() 
{
    //windowHalfX = window.innerWidth / 2;
    //windowHalfY = window.innerHeight / 2;   
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    //
    
    if (effect)
    {
    	setSize( window.innerWidth, window.innerHeight );
    }
    else
    {
    	renderer.setSize( window.innerWidth, window.innerHeight );
    	render();
    
    }
    
    //render();
    
    
    
}


function animate() 
{
	
    // schedule next one

    if (effect) 
    { 
      effect.requestAnimationFrame( animate ); 
    }
    else
    {
      requestAnimationFrame( animate );
    }
    

    var tnow = (new Date()).getTime();

    if (!pars.animate)
        {
         scene.getObjectByName( 'hits' ).children[0].material.uniforms.eventtime.value = eventtime;
         eventtime = 2e100;
        }
    else
        { 
        // --- animation time ---    
        var slowdown = pars.ns_per_s /1000.0 ;         
        var tx = tnow * slowdown;

        var t1 = evt.timerange[0] - pars.introTime;
        var t2 = evt.timerange[1] + 255.0 * pars.aniTotFactor + pars.outroTime
                 
        eventtime = ( tx % (t2-t1)) + t1 ;
	callbacks.animateTracks( eventtime );

        

    if (pars.hitStyle == 'cone')
        {
         scene.getObjectByName( 'hits' ).children[0].material.uniforms.eventtime.value = eventtime;
        }
    else
        {
         if (pars.animate) {callbacks.animateHits_manymeshes()};
        }

	}



    if ( typeof animate.tthen == 'undefined' ) animate.tthen = tnow;
    
    var dt = animate.tthen-tnow;
    animate.tthen = tnow;

	callbacks.vr_demo( tnow )

	 if ( pars.rotate ) 
     {
        var ax = new THREE.Vector3( 0, 1, 0 );  
        camera.position.applyAxisAngle( ax , 0.00001* pars.rotationSpeed * dt );
     }
    
    controls.update();
    stats.update();     
    render();
}

;

render = function() {
  if (render.n == null) {
    render.n = 0;
  }
  render.n += 1;
  THREE.VRController.update();
  if (effect) {
    return effect.render(scene, camera);
  } else {
    return renderer.render(scene, camera);
  }
};

newwindow = function() {
  return window.new_window_ref = window.open(window.location);
};

container = document.createElement('container');

container.id = "container";

document.body.appendChild(container);

initdiv = document.createElement('div');

initdiv.id = 'init';

initdiv.innerHTML = '<br>aa3d starting up.</br>';

document.body.appendChild(initdiv);

unzip = function(buf) {
  var U, i, j, ref, result, words;
  words = new Uint8Array(buf);
  U = pako.ungzip(words);
  console.log(U);
  result = "";
  for (i = j = 0, ref = U.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    result += String.fromCharCode(U[i]);
  }
  return result;
};

str_endsWith = function(s, suffix) {
  return s.indexOf(suffix, s.length - suffix.length) !== -1;
};

antares_mode = function() {
  console.log("antares mode");
  pars.set("domFragmentShader", "fragmentshader_antares_glsl");
  pars.set("camHeight", 200);
  pars.set("camDistance", 250);
  pars.set("domSize", 2.0);
  pars.set("domFactor", 3);
  pars.set("hitStyle", "sphere");
  pars.set("ampFunc", "Math.sqrt(hit.a)");
  pars.set("palette", "hue");
  pars.set("hitLength", 1.5);
  return pars.set("depthSortEvery", 0);
};

loadFile = function(url, asynch, when_done) {
  var gz, process, xmlhttp;
  if (asynch == null) {
    asynch = true;
  }
  console.log(url, when_done, asynch);
  gz = str_endsWith(url, ".gz");
  xmlhttp = new XMLHttpRequest();
  if (gz) {
    xmlhttp.responseType = 'arraybuffer';
  }
  process = function(req) {
    var s;
    if (gz) {
      s = unzip(xmlhttp.response);
      eval(s);
    } else {
      eval(xmlhttp.responseText);
    }
    return typeof when_done === "function" ? when_done() : void 0;
  };
  if (asynch) {
    xmlhttp.onprogress = function(ev) {
      return console.log('getting file:' + url + ' __ ' + ev.loaded / 1e6 + ' MB');
    };
    xmlhttp.onreadystatechange = function() {
      if (xmlhttp.readyState !== 4) {
        return;
      }
      if (xmlhttp.status !== 200) {
        return;
      }
      console.log("done");
      return process(xmlhttp);
    };
  }
  xmlhttp.open("GET", url, asynch);
  xmlhttp.send();
  if (!asynch) {
    return process(xmlhttp);
  }
};

process_event = function(data) {
    console.log("Recieved data from RBA");
    try {
        var evt = parse_jdaqevent(data);
    } catch(ParseError) {
        console.log("Unable to parse binary data from RBA. Trying to execute it instead...");
        try {
            eval(data);
        } catch(SyntaxError) {
            console.log("Unable to evaluate data from RBA.");
        }
    }
}

parse_jdaqevent = function(data) {
    console.log("Parsing " + data.length + " bytes of event data.");
    var buffer = new ArrayBuffer(16);  // for the header (length + datatype)

    // the following doesn't work yet
    var length = new Uint32Array(buffer, 0, 4);
    console.log(length);
    throw "ParseError";
}

many_screenshots = function(i) {
  var fn, j, len, results1, s, scfile;
  if (i == null) {
    i = 0;
  }
  s = "diffuse2017/detevt_28722_45202_426\ndiffuse2017/detevt_35473_7183_1050\ndiffuse2017/detevt_38472_61820_16446\ndiffuse2017/detevt_38518_41252_24091\ndiffuse2017/detevt_38519_42310_26116\ndiffuse2017/detevt_39324_118871_32515\ndiffuse2017/detevt_45265_79259_997305\ndiffuse2017/detevt_45835_34256_1041663\ndiffuse2017/detevt_46852_51708_917709\ndiffuse2017/detevt_47833_1124_537259\ndiffuse2017/detevt_49425_32175_104853\ndiffuse2017/detevt_49821_56923_25516\ndiffuse2017/detevt_49853_25438_1385\ndiffuse2017/detevt_53037_101247_36731\ndiffuse2017/detevt_53060_41698_354601\ndiffuse2017/detevt_54260_1639_2925759\ndiffuse2017/detevt_57495_15712_326824\ndiffuse2017/detevt_60896_68105_494258\ndiffuse2017/detevt_60907_60252_572415\ndiffuse2017/detevt_61023_10375_2179659\ndiffuse2017/detevt_62657_88204_22071\ndiffuse2017/detevt_62834_30474_384475\ndiffuse2017/detevt_65811_20990_137527\ndiffuse2017/detevt_68473_32777_22562\ndiffuse2017/detevt_68883_33383_1459227\ndiffuse2017/detevt_70787_9986_323373\ndiffuse2017/detevt_71534_74641_364543\ndiffuse2017/detevt_74307_193564_6908522\ndiffuse2017/detevt_77640_77424_3612\ndiffuse2017/detevt_80885_49449_12484201\ndiffuse2017/detevt_81667_163768_2732223\ndiffuse2017/detevt_82539_9289_2425758\ndiffuse2017/detevt_82676_118860_167410".split("\n");
  results1 = [];
  for (j = 0, len = s.length; j < len; j++) {
    fn = s[j];
    if (!fn) {
      continue;
    }
    scfile = fn.split("/").pop();
    results1.push(loadFile(fn, false, function() {
      callbacks.onNewEvent();
      callbacks.onNewDetector();
      render();
      return callbacks.write_screenshot(scfile);
    }));
  }
  return results1;
};

if (window.opener) {
  console.log("we have an opener", window.opener);
}


window.addEventListener( 'vr controller connected', function( event ){


    console.log("VR CONTROLLER!!!!!!!!!!!!!!!!!!!!!!!!!");
    
	//  Here it is, your VR controller instance.
	//  It’s really a THREE.Object3D so you can just add it to your scene:

	controller = event.detail
	train.add( controller )


	//  HEY HEY HEY! This is important. You need to make sure you do this.
	//  For standing experiences (not seated) we need to set the standingMatrix
	//  otherwise you’ll wonder why your controller appears on the floor
	//  instead of in your hands! And for seated experiences this will have no
	//  effect, so safe to do either way:

	controller.standingMatrix = renderer.vr.getStandingMatrix()


	//  And for 3DOF (seated) controllers you need to set the controller.head
	//  to reference your camera. That way we can make an educated guess where
	//  your hand ought to appear based on the camera’s rotation.

	controller.head = window.camera


	//  Right now your controller has no visual.
	//  It’s just an empty THREE.Object3D.
	//  Let’s fix that!

	var
	meshColorOff = 0xFF4040,
	meshColorOn  = 0xFFFF00,
	controllerMaterial = new THREE.MeshStandardMaterial({

		color: meshColorOff,
		shading: THREE.FlatShading
	}),
	controllerMesh = new THREE.Mesh(

		new THREE.CylinderGeometry( 0.005, 0.05, 0.1, 6 ),
		controllerMaterial
	),
	handleMesh = new THREE.Mesh(

		new THREE.BoxGeometry( 0.03, 0.1, 0.03 ),
		controllerMaterial
	)

    //controllerMesh.scale.set(100,100,100);
	controllerMesh.rotation.x = -Math.PI / 2;
	handleMesh.position.y = -0.05;
	controllerMesh.add( handleMesh );
	controller.userData.mesh = controllerMesh;//  So we can change the color later.
	controller.add( controllerMesh );


	//  Allow this controller to interact with DAT GUI.

	//var guiInputHelper = dat.GUIVR.addInputObject( controller )
	//scene.add( guiInputHelper )


	//  Button events. How easy is this?!
	//  We’ll just use the “primary” button -- whatever that might be ;)
	//  Check out the THREE.VRController.supported{} object to see
	//  all the named buttons we’ve already mapped for you!

	controller.addEventListener( 'primary press began', function( event ){
        train.position.add( controller.rotation );
		event.target.userData.mesh.material.color.setHex( meshColorOn )
		//guiInputHelper.pressed( true )
	})
	controller.addEventListener( 'primary press ended', function( event ){

		event.target.userData.mesh.material.color.setHex( meshColorOff )
		//guiInputHelper.pressed( false )
	})


	//  Daddy, what happens when we die?

	controller.addEventListener( 'disconnected', function( event ){

		controller.parent.remove( controller )
	})
})
;

url = getUrlPar('f');

if (url === "none") {
  init();
  render();
  animate();
}

if (!url) {
  url = "detevt2_km3.js";
}

initdiv.innerHTML = '<br>getting file:' + url + '</br>';

console.log('get', url);

loadFile(url, true, function() {
  callbacks.onNewEvent();
  init();
  callbacks.onNewDetector();
  render();
  return animate();
});
